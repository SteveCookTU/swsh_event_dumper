// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod structure {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum NestHoleDistributionEncounter8ArchiveOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NestHoleDistributionEncounter8Archive<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NestHoleDistributionEncounter8Archive<'a> {
    type Inner = NestHoleDistributionEncounter8Archive<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> NestHoleDistributionEncounter8Archive<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NestHoleDistributionEncounter8Archive { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NestHoleDistributionEncounter8ArchiveArgs<'args>) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'bldr>> {
      let mut builder = NestHoleDistributionEncounter8ArchiveBuilder::new(_fbb);
      if let Some(x) = args.Tables { builder.add_Tables(x); }
      builder.finish()
    }

    pub const VT_TABLES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn Tables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table>>>>(NestHoleDistributionEncounter8Archive::VT_TABLES, None)
  }
}

impl flatbuffers::Verifiable for NestHoleDistributionEncounter8Archive<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table>>>>(&"Tables", Self::VT_TABLES, false)?
     .finish();
    Ok(())
  }
}
pub struct NestHoleDistributionEncounter8ArchiveArgs<'a> {
    pub Tables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table<'a>>>>>,
}
impl<'a> Default for NestHoleDistributionEncounter8ArchiveArgs<'a> {
    #[inline]
    fn default() -> Self {
        NestHoleDistributionEncounter8ArchiveArgs {
            Tables: None,
        }
    }
}
pub struct NestHoleDistributionEncounter8ArchiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NestHoleDistributionEncounter8ArchiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_Tables(&mut self, Tables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8Table<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NestHoleDistributionEncounter8Archive::VT_TABLES, Tables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NestHoleDistributionEncounter8ArchiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NestHoleDistributionEncounter8ArchiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for NestHoleDistributionEncounter8Archive<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("NestHoleDistributionEncounter8Archive");
      ds.field("Tables", &self.Tables());
      ds.finish()
  }
}
pub enum NestHoleDistributionEncounter8TableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NestHoleDistributionEncounter8Table<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NestHoleDistributionEncounter8Table<'a> {
    type Inner = NestHoleDistributionEncounter8Table<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> NestHoleDistributionEncounter8Table<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NestHoleDistributionEncounter8Table { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NestHoleDistributionEncounter8TableArgs<'args>) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Table<'bldr>> {
      let mut builder = NestHoleDistributionEncounter8TableBuilder::new(_fbb);
      builder.add_TableID(args.TableID);
      if let Some(x) = args.Entries { builder.add_Entries(x); }
      builder.add_GameVersion(args.GameVersion);
      builder.add_Field_03(args.Field_03);
      builder.add_Field_02(args.Field_02);
      builder.finish()
    }

    pub const VT_TABLEID: flatbuffers::VOffsetT = 4;
    pub const VT_GAMEVERSION: flatbuffers::VOffsetT = 6;
    pub const VT_FIELD_02: flatbuffers::VOffsetT = 8;
    pub const VT_FIELD_03: flatbuffers::VOffsetT = 10;
    pub const VT_ENTRIES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn TableID(&self) -> u64 {
    self._tab.get::<u64>(NestHoleDistributionEncounter8Table::VT_TABLEID, Some(0)).unwrap()
  }
  #[inline]
  pub fn GameVersion(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8Table::VT_GAMEVERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_02(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8Table::VT_FIELD_02, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_03(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8Table::VT_FIELD_03, Some(0)).unwrap()
  }
  #[inline]
  pub fn Entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8>>>>(NestHoleDistributionEncounter8Table::VT_ENTRIES, None)
  }
}

impl flatbuffers::Verifiable for NestHoleDistributionEncounter8Table<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>(&"TableID", Self::VT_TABLEID, false)?
     .visit_field::<u32>(&"GameVersion", Self::VT_GAMEVERSION, false)?
     .visit_field::<i8>(&"Field_02", Self::VT_FIELD_02, false)?
     .visit_field::<i8>(&"Field_03", Self::VT_FIELD_03, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8>>>>(&"Entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct NestHoleDistributionEncounter8TableArgs<'a> {
    pub TableID: u64,
    pub GameVersion: u32,
    pub Field_02: i8,
    pub Field_03: i8,
    pub Entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8<'a>>>>>,
}
impl<'a> Default for NestHoleDistributionEncounter8TableArgs<'a> {
    #[inline]
    fn default() -> Self {
        NestHoleDistributionEncounter8TableArgs {
            TableID: 0,
            GameVersion: 0,
            Field_02: 0,
            Field_03: 0,
            Entries: None,
        }
    }
}
pub struct NestHoleDistributionEncounter8TableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NestHoleDistributionEncounter8TableBuilder<'a, 'b> {
  #[inline]
  pub fn add_TableID(&mut self, TableID: u64) {
    self.fbb_.push_slot::<u64>(NestHoleDistributionEncounter8Table::VT_TABLEID, TableID, 0);
  }
  #[inline]
  pub fn add_GameVersion(&mut self, GameVersion: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8Table::VT_GAMEVERSION, GameVersion, 0);
  }
  #[inline]
  pub fn add_Field_02(&mut self, Field_02: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8Table::VT_FIELD_02, Field_02, 0);
  }
  #[inline]
  pub fn add_Field_03(&mut self, Field_03: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8Table::VT_FIELD_03, Field_03, 0);
  }
  #[inline]
  pub fn add_Entries(&mut self, Entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<NestHoleDistributionEncounter8<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NestHoleDistributionEncounter8Table::VT_ENTRIES, Entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NestHoleDistributionEncounter8TableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NestHoleDistributionEncounter8TableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8Table<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for NestHoleDistributionEncounter8Table<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("NestHoleDistributionEncounter8Table");
      ds.field("TableID", &self.TableID());
      ds.field("GameVersion", &self.GameVersion());
      ds.field("Field_02", &self.Field_02());
      ds.field("Field_03", &self.Field_03());
      ds.field("Entries", &self.Entries());
      ds.finish()
  }
}
pub enum NestHoleDistributionEncounter8Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NestHoleDistributionEncounter8<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NestHoleDistributionEncounter8<'a> {
    type Inner = NestHoleDistributionEncounter8<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> NestHoleDistributionEncounter8<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NestHoleDistributionEncounter8 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NestHoleDistributionEncounter8Args<'args>) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8<'bldr>> {
      let mut builder = NestHoleDistributionEncounter8Builder::new(_fbb);
      builder.add_BonusTableID(args.BonusTableID);
      builder.add_DropTableID(args.DropTableID);
      builder.add_AdditionalMove2PP(args.AdditionalMove2PP);
      builder.add_AdditionalMove2(args.AdditionalMove2);
      builder.add_AdditionalMove2Rate(args.AdditionalMove2Rate);
      builder.add_AdditionalMove1PP(args.AdditionalMove1PP);
      builder.add_AdditionalMove1(args.AdditionalMove1);
      builder.add_AdditionalMove1Rate(args.AdditionalMove1Rate);
      builder.add_Shield(args.Shield);
      builder.add_Field_1D(args.Field_1D);
      builder.add_Field_1C(args.Field_1C);
      builder.add_DynamaxBoost(args.DynamaxBoost);
      builder.add_Move3(args.Move3);
      builder.add_Move2(args.Move2);
      builder.add_Move1(args.Move1);
      builder.add_Move0(args.Move0);
      builder.add_Field_16(args.Field_16);
      if let Some(x) = args.Probabilities { builder.add_Probabilities(x); }
      builder.add_Field_0A(args.Field_0A);
      builder.add_Field_09(args.Field_09);
      builder.add_Field_08(args.Field_08);
      builder.add_Field_07(args.Field_07);
      builder.add_Field_06(args.Field_06);
      builder.add_Field_05(args.Field_05);
      builder.add_Level(args.Level);
      builder.add_AltForm(args.AltForm);
      builder.add_Species(args.Species);
      builder.add_EntryIndex(args.EntryIndex);
      builder.add_DynamaxLevel(args.DynamaxLevel);
      builder.add_Nature(args.Nature);
      builder.add_Field_14(args.Field_14);
      builder.add_Field_13(args.Field_13);
      builder.add_ShinyFlag(args.ShinyFlag);
      builder.add_FlawlessIVs(args.FlawlessIVs);
      builder.add_Gender(args.Gender);
      builder.add_IsGigantamax(args.IsGigantamax);
      builder.add_Ability(args.Ability);
      builder.finish()
    }

    pub const VT_ENTRYINDEX: flatbuffers::VOffsetT = 4;
    pub const VT_SPECIES: flatbuffers::VOffsetT = 6;
    pub const VT_ALTFORM: flatbuffers::VOffsetT = 8;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_DYNAMAXLEVEL: flatbuffers::VOffsetT = 12;
    pub const VT_FIELD_05: flatbuffers::VOffsetT = 14;
    pub const VT_FIELD_06: flatbuffers::VOffsetT = 16;
    pub const VT_FIELD_07: flatbuffers::VOffsetT = 18;
    pub const VT_FIELD_08: flatbuffers::VOffsetT = 20;
    pub const VT_FIELD_09: flatbuffers::VOffsetT = 22;
    pub const VT_FIELD_0A: flatbuffers::VOffsetT = 24;
    pub const VT_ABILITY: flatbuffers::VOffsetT = 26;
    pub const VT_ISGIGANTAMAX: flatbuffers::VOffsetT = 28;
    pub const VT_DROPTABLEID: flatbuffers::VOffsetT = 30;
    pub const VT_BONUSTABLEID: flatbuffers::VOffsetT = 32;
    pub const VT_PROBABILITIES: flatbuffers::VOffsetT = 34;
    pub const VT_GENDER: flatbuffers::VOffsetT = 36;
    pub const VT_FLAWLESSIVS: flatbuffers::VOffsetT = 38;
    pub const VT_SHINYFLAG: flatbuffers::VOffsetT = 40;
    pub const VT_FIELD_13: flatbuffers::VOffsetT = 42;
    pub const VT_FIELD_14: flatbuffers::VOffsetT = 44;
    pub const VT_NATURE: flatbuffers::VOffsetT = 46;
    pub const VT_FIELD_16: flatbuffers::VOffsetT = 48;
    pub const VT_MOVE0: flatbuffers::VOffsetT = 50;
    pub const VT_MOVE1: flatbuffers::VOffsetT = 52;
    pub const VT_MOVE2: flatbuffers::VOffsetT = 54;
    pub const VT_MOVE3: flatbuffers::VOffsetT = 56;
    pub const VT_DYNAMAXBOOST: flatbuffers::VOffsetT = 58;
    pub const VT_FIELD_1C: flatbuffers::VOffsetT = 60;
    pub const VT_FIELD_1D: flatbuffers::VOffsetT = 62;
    pub const VT_SHIELD: flatbuffers::VOffsetT = 64;
    pub const VT_ADDITIONALMOVE1RATE: flatbuffers::VOffsetT = 66;
    pub const VT_ADDITIONALMOVE1: flatbuffers::VOffsetT = 68;
    pub const VT_ADDITIONALMOVE1PP: flatbuffers::VOffsetT = 70;
    pub const VT_ADDITIONALMOVE2RATE: flatbuffers::VOffsetT = 72;
    pub const VT_ADDITIONALMOVE2: flatbuffers::VOffsetT = 74;
    pub const VT_ADDITIONALMOVE2PP: flatbuffers::VOffsetT = 76;

  #[inline]
  pub fn EntryIndex(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ENTRYINDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn Species(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_SPECIES, Some(0)).unwrap()
  }
  #[inline]
  pub fn AltForm(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ALTFORM, Some(0)).unwrap()
  }
  #[inline]
  pub fn Level(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_LEVEL, Some(0)).unwrap()
  }
  #[inline]
  pub fn DynamaxLevel(&self) -> u16 {
    self._tab.get::<u16>(NestHoleDistributionEncounter8::VT_DYNAMAXLEVEL, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_05(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_05, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_06(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_06, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_07(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_07, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_08(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_08, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_09(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_09, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_0A(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_0A, Some(0)).unwrap()
  }
  #[inline]
  pub fn Ability(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8::VT_ABILITY, Some(0)).unwrap()
  }
  #[inline]
  pub fn IsGigantamax(&self) -> bool {
    self._tab.get::<bool>(NestHoleDistributionEncounter8::VT_ISGIGANTAMAX, Some(false)).unwrap()
  }
  #[inline]
  pub fn DropTableID(&self) -> u64 {
    self._tab.get::<u64>(NestHoleDistributionEncounter8::VT_DROPTABLEID, Some(0)).unwrap()
  }
  #[inline]
  pub fn BonusTableID(&self) -> u64 {
    self._tab.get::<u64>(NestHoleDistributionEncounter8::VT_BONUSTABLEID, Some(0)).unwrap()
  }
  #[inline]
  pub fn Probabilities(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(NestHoleDistributionEncounter8::VT_PROBABILITIES, None)
  }
  #[inline]
  pub fn Gender(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8::VT_GENDER, Some(0)).unwrap()
  }
  #[inline]
  pub fn FlawlessIVs(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8::VT_FLAWLESSIVS, Some(0)).unwrap()
  }
  #[inline]
  pub fn ShinyFlag(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8::VT_SHINYFLAG, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_13(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8::VT_FIELD_13, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_14(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8::VT_FIELD_14, Some(0)).unwrap()
  }
  #[inline]
  pub fn Nature(&self) -> i8 {
    self._tab.get::<i8>(NestHoleDistributionEncounter8::VT_NATURE, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_16(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_16, Some(0)).unwrap()
  }
  #[inline]
  pub fn Move0(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_MOVE0, Some(0)).unwrap()
  }
  #[inline]
  pub fn Move1(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_MOVE1, Some(0)).unwrap()
  }
  #[inline]
  pub fn Move2(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_MOVE2, Some(0)).unwrap()
  }
  #[inline]
  pub fn Move3(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_MOVE3, Some(0)).unwrap()
  }
  #[inline]
  pub fn DynamaxBoost(&self) -> f32 {
    self._tab.get::<f32>(NestHoleDistributionEncounter8::VT_DYNAMAXBOOST, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn Field_1C(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1C, Some(0)).unwrap()
  }
  #[inline]
  pub fn Field_1D(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1D, Some(0)).unwrap()
  }
  #[inline]
  pub fn Shield(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_SHIELD, Some(0)).unwrap()
  }
  #[inline]
  pub fn AdditionalMove1Rate(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1RATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn AdditionalMove1(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1, Some(0)).unwrap()
  }
  #[inline]
  pub fn AdditionalMove1PP(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1PP, Some(0)).unwrap()
  }
  #[inline]
  pub fn AdditionalMove2Rate(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2RATE, Some(0)).unwrap()
  }
  #[inline]
  pub fn AdditionalMove2(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2, Some(0)).unwrap()
  }
  #[inline]
  pub fn AdditionalMove2PP(&self) -> u32 {
    self._tab.get::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2PP, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for NestHoleDistributionEncounter8<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"EntryIndex", Self::VT_ENTRYINDEX, false)?
     .visit_field::<u32>(&"Species", Self::VT_SPECIES, false)?
     .visit_field::<u32>(&"AltForm", Self::VT_ALTFORM, false)?
     .visit_field::<u32>(&"Level", Self::VT_LEVEL, false)?
     .visit_field::<u16>(&"DynamaxLevel", Self::VT_DYNAMAXLEVEL, false)?
     .visit_field::<u32>(&"Field_05", Self::VT_FIELD_05, false)?
     .visit_field::<u32>(&"Field_06", Self::VT_FIELD_06, false)?
     .visit_field::<u32>(&"Field_07", Self::VT_FIELD_07, false)?
     .visit_field::<u32>(&"Field_08", Self::VT_FIELD_08, false)?
     .visit_field::<u32>(&"Field_09", Self::VT_FIELD_09, false)?
     .visit_field::<u32>(&"Field_0A", Self::VT_FIELD_0A, false)?
     .visit_field::<i8>(&"Ability", Self::VT_ABILITY, false)?
     .visit_field::<bool>(&"IsGigantamax", Self::VT_ISGIGANTAMAX, false)?
     .visit_field::<u64>(&"DropTableID", Self::VT_DROPTABLEID, false)?
     .visit_field::<u64>(&"BonusTableID", Self::VT_BONUSTABLEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"Probabilities", Self::VT_PROBABILITIES, false)?
     .visit_field::<i8>(&"Gender", Self::VT_GENDER, false)?
     .visit_field::<i8>(&"FlawlessIVs", Self::VT_FLAWLESSIVS, false)?
     .visit_field::<i8>(&"ShinyFlag", Self::VT_SHINYFLAG, false)?
     .visit_field::<i8>(&"Field_13", Self::VT_FIELD_13, false)?
     .visit_field::<i8>(&"Field_14", Self::VT_FIELD_14, false)?
     .visit_field::<i8>(&"Nature", Self::VT_NATURE, false)?
     .visit_field::<u32>(&"Field_16", Self::VT_FIELD_16, false)?
     .visit_field::<u32>(&"Move0", Self::VT_MOVE0, false)?
     .visit_field::<u32>(&"Move1", Self::VT_MOVE1, false)?
     .visit_field::<u32>(&"Move2", Self::VT_MOVE2, false)?
     .visit_field::<u32>(&"Move3", Self::VT_MOVE3, false)?
     .visit_field::<f32>(&"DynamaxBoost", Self::VT_DYNAMAXBOOST, false)?
     .visit_field::<u32>(&"Field_1C", Self::VT_FIELD_1C, false)?
     .visit_field::<u32>(&"Field_1D", Self::VT_FIELD_1D, false)?
     .visit_field::<u32>(&"Shield", Self::VT_SHIELD, false)?
     .visit_field::<u32>(&"AdditionalMove1Rate", Self::VT_ADDITIONALMOVE1RATE, false)?
     .visit_field::<u32>(&"AdditionalMove1", Self::VT_ADDITIONALMOVE1, false)?
     .visit_field::<u32>(&"AdditionalMove1PP", Self::VT_ADDITIONALMOVE1PP, false)?
     .visit_field::<u32>(&"AdditionalMove2Rate", Self::VT_ADDITIONALMOVE2RATE, false)?
     .visit_field::<u32>(&"AdditionalMove2", Self::VT_ADDITIONALMOVE2, false)?
     .visit_field::<u32>(&"AdditionalMove2PP", Self::VT_ADDITIONALMOVE2PP, false)?
     .finish();
    Ok(())
  }
}
pub struct NestHoleDistributionEncounter8Args<'a> {
    pub EntryIndex: u32,
    pub Species: u32,
    pub AltForm: u32,
    pub Level: u32,
    pub DynamaxLevel: u16,
    pub Field_05: u32,
    pub Field_06: u32,
    pub Field_07: u32,
    pub Field_08: u32,
    pub Field_09: u32,
    pub Field_0A: u32,
    pub Ability: i8,
    pub IsGigantamax: bool,
    pub DropTableID: u64,
    pub BonusTableID: u64,
    pub Probabilities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub Gender: i8,
    pub FlawlessIVs: i8,
    pub ShinyFlag: i8,
    pub Field_13: i8,
    pub Field_14: i8,
    pub Nature: i8,
    pub Field_16: u32,
    pub Move0: u32,
    pub Move1: u32,
    pub Move2: u32,
    pub Move3: u32,
    pub DynamaxBoost: f32,
    pub Field_1C: u32,
    pub Field_1D: u32,
    pub Shield: u32,
    pub AdditionalMove1Rate: u32,
    pub AdditionalMove1: u32,
    pub AdditionalMove1PP: u32,
    pub AdditionalMove2Rate: u32,
    pub AdditionalMove2: u32,
    pub AdditionalMove2PP: u32,
}
impl<'a> Default for NestHoleDistributionEncounter8Args<'a> {
    #[inline]
    fn default() -> Self {
        NestHoleDistributionEncounter8Args {
            EntryIndex: 0,
            Species: 0,
            AltForm: 0,
            Level: 0,
            DynamaxLevel: 0,
            Field_05: 0,
            Field_06: 0,
            Field_07: 0,
            Field_08: 0,
            Field_09: 0,
            Field_0A: 0,
            Ability: 0,
            IsGigantamax: false,
            DropTableID: 0,
            BonusTableID: 0,
            Probabilities: None,
            Gender: 0,
            FlawlessIVs: 0,
            ShinyFlag: 0,
            Field_13: 0,
            Field_14: 0,
            Nature: 0,
            Field_16: 0,
            Move0: 0,
            Move1: 0,
            Move2: 0,
            Move3: 0,
            DynamaxBoost: 0.0,
            Field_1C: 0,
            Field_1D: 0,
            Shield: 0,
            AdditionalMove1Rate: 0,
            AdditionalMove1: 0,
            AdditionalMove1PP: 0,
            AdditionalMove2Rate: 0,
            AdditionalMove2: 0,
            AdditionalMove2PP: 0,
        }
    }
}
pub struct NestHoleDistributionEncounter8Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NestHoleDistributionEncounter8Builder<'a, 'b> {
  #[inline]
  pub fn add_EntryIndex(&mut self, EntryIndex: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ENTRYINDEX, EntryIndex, 0);
  }
  #[inline]
  pub fn add_Species(&mut self, Species: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_SPECIES, Species, 0);
  }
  #[inline]
  pub fn add_AltForm(&mut self, AltForm: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ALTFORM, AltForm, 0);
  }
  #[inline]
  pub fn add_Level(&mut self, Level: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_LEVEL, Level, 0);
  }
  #[inline]
  pub fn add_DynamaxLevel(&mut self, DynamaxLevel: u16) {
    self.fbb_.push_slot::<u16>(NestHoleDistributionEncounter8::VT_DYNAMAXLEVEL, DynamaxLevel, 0);
  }
  #[inline]
  pub fn add_Field_05(&mut self, Field_05: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_05, Field_05, 0);
  }
  #[inline]
  pub fn add_Field_06(&mut self, Field_06: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_06, Field_06, 0);
  }
  #[inline]
  pub fn add_Field_07(&mut self, Field_07: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_07, Field_07, 0);
  }
  #[inline]
  pub fn add_Field_08(&mut self, Field_08: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_08, Field_08, 0);
  }
  #[inline]
  pub fn add_Field_09(&mut self, Field_09: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_09, Field_09, 0);
  }
  #[inline]
  pub fn add_Field_0A(&mut self, Field_0A: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_0A, Field_0A, 0);
  }
  #[inline]
  pub fn add_Ability(&mut self, Ability: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8::VT_ABILITY, Ability, 0);
  }
  #[inline]
  pub fn add_IsGigantamax(&mut self, IsGigantamax: bool) {
    self.fbb_.push_slot::<bool>(NestHoleDistributionEncounter8::VT_ISGIGANTAMAX, IsGigantamax, false);
  }
  #[inline]
  pub fn add_DropTableID(&mut self, DropTableID: u64) {
    self.fbb_.push_slot::<u64>(NestHoleDistributionEncounter8::VT_DROPTABLEID, DropTableID, 0);
  }
  #[inline]
  pub fn add_BonusTableID(&mut self, BonusTableID: u64) {
    self.fbb_.push_slot::<u64>(NestHoleDistributionEncounter8::VT_BONUSTABLEID, BonusTableID, 0);
  }
  #[inline]
  pub fn add_Probabilities(&mut self, Probabilities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NestHoleDistributionEncounter8::VT_PROBABILITIES, Probabilities);
  }
  #[inline]
  pub fn add_Gender(&mut self, Gender: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8::VT_GENDER, Gender, 0);
  }
  #[inline]
  pub fn add_FlawlessIVs(&mut self, FlawlessIVs: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8::VT_FLAWLESSIVS, FlawlessIVs, 0);
  }
  #[inline]
  pub fn add_ShinyFlag(&mut self, ShinyFlag: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8::VT_SHINYFLAG, ShinyFlag, 0);
  }
  #[inline]
  pub fn add_Field_13(&mut self, Field_13: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8::VT_FIELD_13, Field_13, 0);
  }
  #[inline]
  pub fn add_Field_14(&mut self, Field_14: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8::VT_FIELD_14, Field_14, 0);
  }
  #[inline]
  pub fn add_Nature(&mut self, Nature: i8) {
    self.fbb_.push_slot::<i8>(NestHoleDistributionEncounter8::VT_NATURE, Nature, 0);
  }
  #[inline]
  pub fn add_Field_16(&mut self, Field_16: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_16, Field_16, 0);
  }
  #[inline]
  pub fn add_Move0(&mut self, Move0: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE0, Move0, 0);
  }
  #[inline]
  pub fn add_Move1(&mut self, Move1: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE1, Move1, 0);
  }
  #[inline]
  pub fn add_Move2(&mut self, Move2: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE2, Move2, 0);
  }
  #[inline]
  pub fn add_Move3(&mut self, Move3: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_MOVE3, Move3, 0);
  }
  #[inline]
  pub fn add_DynamaxBoost(&mut self, DynamaxBoost: f32) {
    self.fbb_.push_slot::<f32>(NestHoleDistributionEncounter8::VT_DYNAMAXBOOST, DynamaxBoost, 0.0);
  }
  #[inline]
  pub fn add_Field_1C(&mut self, Field_1C: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1C, Field_1C, 0);
  }
  #[inline]
  pub fn add_Field_1D(&mut self, Field_1D: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_FIELD_1D, Field_1D, 0);
  }
  #[inline]
  pub fn add_Shield(&mut self, Shield: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_SHIELD, Shield, 0);
  }
  #[inline]
  pub fn add_AdditionalMove1Rate(&mut self, AdditionalMove1Rate: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1RATE, AdditionalMove1Rate, 0);
  }
  #[inline]
  pub fn add_AdditionalMove1(&mut self, AdditionalMove1: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1, AdditionalMove1, 0);
  }
  #[inline]
  pub fn add_AdditionalMove1PP(&mut self, AdditionalMove1PP: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1PP, AdditionalMove1PP, 0);
  }
  #[inline]
  pub fn add_AdditionalMove2Rate(&mut self, AdditionalMove2Rate: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2RATE, AdditionalMove2Rate, 0);
  }
  #[inline]
  pub fn add_AdditionalMove2(&mut self, AdditionalMove2: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2, AdditionalMove2, 0);
  }
  #[inline]
  pub fn add_AdditionalMove2PP(&mut self, AdditionalMove2PP: u32) {
    self.fbb_.push_slot::<u32>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2PP, AdditionalMove2PP, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NestHoleDistributionEncounter8Builder<'a, 'b> {
    let start = _fbb.start_table();
    NestHoleDistributionEncounter8Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NestHoleDistributionEncounter8<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for NestHoleDistributionEncounter8<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("NestHoleDistributionEncounter8");
      ds.field("EntryIndex", &self.EntryIndex());
      ds.field("Species", &self.Species());
      ds.field("AltForm", &self.AltForm());
      ds.field("Level", &self.Level());
      ds.field("DynamaxLevel", &self.DynamaxLevel());
      ds.field("Field_05", &self.Field_05());
      ds.field("Field_06", &self.Field_06());
      ds.field("Field_07", &self.Field_07());
      ds.field("Field_08", &self.Field_08());
      ds.field("Field_09", &self.Field_09());
      ds.field("Field_0A", &self.Field_0A());
      ds.field("Ability", &self.Ability());
      ds.field("IsGigantamax", &self.IsGigantamax());
      ds.field("DropTableID", &self.DropTableID());
      ds.field("BonusTableID", &self.BonusTableID());
      ds.field("Probabilities", &self.Probabilities());
      ds.field("Gender", &self.Gender());
      ds.field("FlawlessIVs", &self.FlawlessIVs());
      ds.field("ShinyFlag", &self.ShinyFlag());
      ds.field("Field_13", &self.Field_13());
      ds.field("Field_14", &self.Field_14());
      ds.field("Nature", &self.Nature());
      ds.field("Field_16", &self.Field_16());
      ds.field("Move0", &self.Move0());
      ds.field("Move1", &self.Move1());
      ds.field("Move2", &self.Move2());
      ds.field("Move3", &self.Move3());
      ds.field("DynamaxBoost", &self.DynamaxBoost());
      ds.field("Field_1C", &self.Field_1C());
      ds.field("Field_1D", &self.Field_1D());
      ds.field("Shield", &self.Shield());
      ds.field("AdditionalMove1Rate", &self.AdditionalMove1Rate());
      ds.field("AdditionalMove1", &self.AdditionalMove1());
      ds.field("AdditionalMove1PP", &self.AdditionalMove1PP());
      ds.field("AdditionalMove2Rate", &self.AdditionalMove2Rate());
      ds.field("AdditionalMove2", &self.AdditionalMove2());
      ds.field("AdditionalMove2PP", &self.AdditionalMove2PP());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_nest_hole_distribution_encounter_8archive<'a>(buf: &'a [u8]) -> NestHoleDistributionEncounter8Archive<'a> {
  unsafe { flatbuffers::root_unchecked::<NestHoleDistributionEncounter8Archive<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_nest_hole_distribution_encounter_8archive<'a>(buf: &'a [u8]) -> NestHoleDistributionEncounter8Archive<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<NestHoleDistributionEncounter8Archive<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `NestHoleDistributionEncounter8Archive`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_nest_hole_distribution_encounter_8archive_unchecked`.
pub fn root_as_nest_hole_distribution_encounter_8archive(buf: &[u8]) -> Result<NestHoleDistributionEncounter8Archive, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<NestHoleDistributionEncounter8Archive>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `NestHoleDistributionEncounter8Archive` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_nest_hole_distribution_encounter_8archive_unchecked`.
pub fn size_prefixed_root_as_nest_hole_distribution_encounter_8archive(buf: &[u8]) -> Result<NestHoleDistributionEncounter8Archive, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<NestHoleDistributionEncounter8Archive>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `NestHoleDistributionEncounter8Archive` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_nest_hole_distribution_encounter_8archive_unchecked`.
pub fn root_as_nest_hole_distribution_encounter_8archive_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<NestHoleDistributionEncounter8Archive<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<NestHoleDistributionEncounter8Archive<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `NestHoleDistributionEncounter8Archive` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_nest_hole_distribution_encounter_8archive_unchecked`.
pub fn size_prefixed_root_as_nest_hole_distribution_encounter_8archive_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<NestHoleDistributionEncounter8Archive<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<NestHoleDistributionEncounter8Archive<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a NestHoleDistributionEncounter8Archive and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `NestHoleDistributionEncounter8Archive`.
pub unsafe fn root_as_nest_hole_distribution_encounter_8archive_unchecked(buf: &[u8]) -> NestHoleDistributionEncounter8Archive {
  flatbuffers::root_unchecked::<NestHoleDistributionEncounter8Archive>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed NestHoleDistributionEncounter8Archive and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `NestHoleDistributionEncounter8Archive`.
pub unsafe fn size_prefixed_root_as_nest_hole_distribution_encounter_8archive_unchecked(buf: &[u8]) -> NestHoleDistributionEncounter8Archive {
  flatbuffers::size_prefixed_root_unchecked::<NestHoleDistributionEncounter8Archive>(buf)
}
#[inline]
pub fn finish_nest_hole_distribution_encounter_8archive_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_nest_hole_distribution_encounter_8archive_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<NestHoleDistributionEncounter8Archive<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod structure

